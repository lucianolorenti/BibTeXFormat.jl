var documenterSearchIndex = {"docs":
[{"location":"style/#Style-1","page":"Style","title":"Style","text":"","category":"section"},{"location":"style/#Julia-Format-1","page":"Style","title":"Julia Format","text":"","category":"section"},{"location":"style/#Example-1","page":"Style","title":"Example","text":"","category":"section"},{"location":"style/#","page":"Style","title":"Style","text":"using BibTeX\nusing BibTeXFormat\n\nbibliography = Bibliography(readstring(joinpath(Pkg.dir(\"BibTeXFormat\"),\n                             \"test/Clustering.bib\")))\nformatted_entries = format_entries(AlphaStyle,bibliography)\nHTMLoutput        = write_to_string( HTMLBackend(),formatted_entries )","category":"page"},{"location":"style/#","page":"Style","title":"Style","text":"Pages    = [\"style.jl\"]","category":"page"},{"location":"style/#","page":"Style","title":"Style","text":"Modules = [BibTeXFormat]\nPages    = [\"style.jl\"]","category":"page"},{"location":"style/#BibTeXFormat.AlphaStyle","page":"Style","title":"BibTeXFormat.AlphaStyle","text":"Alpha Style\n\nConfig(label_style = AlphaLabelStyle(),sorting_style = AuthorYearTitleSortingStyle())\n\n\n\n\n\n","category":"constant"},{"location":"style/#BibTeXFormat.PlainAlphaStyle","page":"Style","title":"BibTeXFormat.PlainAlphaStyle","text":"PlainAlphaStyle\n\n\n\n\n\n","category":"constant"},{"location":"style/#BibTeXFormat.UNSRTAlphaStyle","page":"Style","title":"BibTeXFormat.UNSRTAlphaStyle","text":"UNSRTAlphaStyle\n\nConfig(label_style = AlphaLabelStyle())\n\n\n\n\n\n","category":"constant"},{"location":"style/#BibTeXFormat.format_entries-Union{Tuple{T}, Tuple{T,Any}} where T<:BaseStyle","page":"Style","title":"BibTeXFormat.format_entries","text":"function format_entries(b::T, entries::Dict) where T <: BaseStyle\n\nFormat a Dict of entries with a given style b::T where T <: BaseStyle\n\nusing BibTeX\nusing BibTeXFormat\nbibliography      = Bibliography(readstring(\"test/Clustering.bib\"))\nformatted_entries = format_entries(AlphaStyle,bibliography)\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.format_entry-Union{Tuple{T}, Tuple{T,Any,Citation}} where T<:BaseStyle","page":"Style","title":"BibTeXFormat.format_entry","text":"function format_entry(b::T, label, entry::Citation) where T <: BaseStyle\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.format_entry-Union{Tuple{T}, Tuple{T,Any,Dict{String,Any}}} where T<:BaseStyle","page":"Style","title":"BibTeXFormat.format_entry","text":"function format_entry(b::T, label, entry) where T <: BaseStyle\n\nFormat an entry with a given style b::T where T <: BaseStyle\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.expand_wildcard_citations-Tuple{Any,Any}","page":"Style","title":"BibTeXFormat.expand_wildcard_citations","text":"Expand wildcard citations (\\citation{*} in .aux file).\n\njulia> using BibTeX\n\njulia> import BibTeXFormat: expand_wildcard_citations, Citation, Bibliography\n\njulia> data = Bibliography(\"\", Dict{String,Citation}(\"uno\"=>Citation{:article}(),\"dos\"=>Citation{:article}(),\"tres\"=>Citation{:article}(),\t\"cuatro\"=>Citation{:article}()));\n\njulia> expand_wildcard_citations(data, [])\n0-element Array{Any,1}\n\njulia> print(expand_wildcard_citations(data, [\"*\"]))\nAny[\"tres\", \"dos\", \"uno\", \"cuatro\"]\njulia> print(expand_wildcard_citations(data, [\"uno\", \"*\"]))\nAny[\"uno\", \"tres\", \"dos\", \"cuatro\"]\njulia> print(expand_wildcard_citations(data, [\"dos\", \"*\"]))\nAny[\"dos\", \"tres\", \"uno\", \"cuatro\"]\njulia> print(expand_wildcard_citations(data, [\"*\", \"uno\"]))\nAny[\"tres\", \"dos\", \"uno\", \"cuatro\"]\njulia> print(expand_wildcard_citations(data, [\"*\", \"DOS\"]))\nAny[\"tres\", \"dos\", \"uno\", \"cuatro\"]\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.format_bibliography-Union{Tuple{T}, Tuple{T,Bibliography}, Tuple{T,Bibliography,Any}} where T<:BaseStyle","page":"Style","title":"BibTeXFormat.format_bibliography","text":"function format_bibliography(self::T, bib_data, citations=nothing) where T<:BaseStyle\n\nFormat bibliography entries with the given keys Params:\n\nself::T where T<:BaseStyle. The style\nbib_data BibTeX.Bibliography\nparam citations: A list of citation keys.\n\nusing BibTeX\nusing BibTeXFormat\nbibliography      = Bibliography(readstring(\"test/Clustering.bib\"))\n\nformatted_entries = format_entries(AlphaStyle,bibliography)\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.get_crossreferenced_citations-Tuple{Any,Any}","page":"Style","title":"BibTeXFormat.get_crossreferenced_citations","text":"Get cititations not cited explicitly but referenced by other citations.\n\njulia> using BibTeX\n\njulia> import BibTeXFormat: get_crossreferenced_citations, Citation, Bibliography\n\njulia> data = Bibliography(\"\", Dict{String,Citation}(\"main_article\"=>Citation{:article}(Dict(\"crossref\"=>\"xrefd_article\")),\"xrefd_article\"=>Citation{:article}()));\n\njulia> print(get_crossreferenced_citations(data, [], min_crossrefs=1))\nAny[]\njulia> print(get_crossreferenced_citations(data, [\"main_article\"], min_crossrefs=1))\nAny[\"xrefd_article\"]\njulia> print(get_crossreferenced_citations(data,[\"Main_article\"], min_crossrefs=1))\nAny[\"xrefd_article\"]\njulia> print(get_crossreferenced_citations(data, [\"main_article\"], min_crossrefs=2))\nAny[]\njulia> print(get_crossreferenced_citations(data, [\"xrefd_arcicle\"], min_crossrefs=1))\nAny[]\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.transform-Tuple{Citation,Any}","page":"Style","title":"BibTeXFormat.transform","text":"function transform(e::Citation, label)\n\nAdd some information to a BibTeX.Citation.\n\n\n\n\n\n","category":"method"},{"location":"style/#BST-1","page":"Style","title":"BST","text":"","category":"section"},{"location":"style/#","page":"Style","title":"Style","text":"using BibTeX\nusing BibTeXFormat\nbibliography = Bibliography(readstring(joinpath(Pkg.dir(\"BibTeXFormat\"), \"test/Clustering.bib\")))\nstyle        = BST.parse_file(joinpath(Pkg.dir(\"BibTeXFormat\"),\"test/format/apacite.bst\"))\nlatexOutput = format_entries(style, bibliography)","category":"page"},{"location":"style/#References-1","page":"Style","title":"References","text":"","category":"section"},{"location":"style/#","page":"Style","title":"Style","text":"Modules=[BibTeXFormat.BST]\nPages = [\"style/bst/bst.jl\", \"style/bst/interpreter.jl\", \"style/bst/names.jl\"]","category":"page"},{"location":"style/#","page":"Style","title":"Style","text":"Modules=[BibTeXFormat.BST]\nPages = [\"style/bst/bst.jl\", \"style/bst/interpreter.jl\", \"style/bst/names.jl\"]","category":"page"},{"location":"style/#BibTeXFormat.BST.Style","page":"Style","title":"BibTeXFormat.BST.Style","text":"type Style <: BaseStyle\n\nA Style obtained from a .bst file\n\n\n\n\n\n","category":"type"},{"location":"style/#BibTeXFormat.BST.parse_file-Tuple{String}","page":"Style","title":"BibTeXFormat.BST.parse_file","text":"function parse_file(filename::String)\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.BST.parse_string-Tuple{String}","page":"Style","title":"BibTeXFormat.BST.parse_string","text":"function parse_string(content::String)\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.BST.run","page":"Style","title":"BibTeXFormat.BST.run","text":"function run(self, citations, bib_files, min_crossrefs):\n\nRun bst script and return formatted bibliography.\n\n\n\n\n\n","category":"function"},{"location":"style/#BibTeXFormat.BST.strip_comment-Tuple{Any}","page":"Style","title":"BibTeXFormat.BST.strip_comment","text":"Strip the commented part of the line.\"\n\njulia> print(strip_comment(\"a normal line\"))\na normal line\njulia> print(strip_comment(\"%\"))\n\njulia> print(strip_comment(\"%comment\"))\n\njulia> print(strip_comment(\"trailing%\"))\ntrailing\njulia> print(strip_comment(\"a normal line% and a comment\"))\na normal line\njulia> print(strip_comment(\"\"100% compatibility\" is a myth\"))\n\"100% compatibility\" is a myth\njulia> print(strip_comment(\"\"100% compatibility\" is a myth% or not?\"))\n\"100% compatibility\" is a myth\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.format_bibliography","page":"Style","title":"BibTeXFormat.format_bibliography","text":"function format_bibliography(self::Style, bib_data, citations=nothing)\n\nFormat bibliography entries with the given keys\n\nParams:\n\nstyle::Style. The BST style\nbib_data\nparam citations: A list of citation keys.\n\n\n\n\n\n","category":"function"},{"location":"style/#BibTeXFormat.format_entries-Tuple{BibTeXFormat.BST.Style,Any}","page":"Style","title":"BibTeXFormat.format_entries","text":"function format_entries(b::Style, entries::Dict)\n\nFormat a Dict of entries with a given style b::Style\n\nusing BibTeX\nusing BibTeXFormat\nbibliography      = Bibliography(readstring(\"test/Clustering.bib\"))\nstyle        = BST.parse_file(joinpath(Pkg.dir(\"BibTeXFormat\"),\"test/format/apacite.bst\"))\nformatted_entries = format_entries(style, bibliography)\n\n\n\n\n\n","category":"method"},{"location":"style/#BibTeXFormat.BST.bst_join","page":"Style","title":"BibTeXFormat.BST.bst_join","text":"function bst_join(words, tie=\"~\", space=\" \")\n\nJoin some words, inserting ties (~) when nessessary.     Ties are inserted:     - after the first word, if it is short     - before the last word     Otherwise space is inserted.     Should produce the same oubput as BibTeX.\n\njulia> import BibTeXFormat.BST: bst_join\n\njulia> print(bst_join([\"a\", \"long\", \"long\", \"road\"]))\na~long long~road\n\njulia> print(bst_join([\"very\", \"long\", \"phrase\"]))\nvery long~phrase\n\njulia> print(bst_join([\"De\", \"La\"]))\nDe~La\n\n\n\n\n\n","category":"function"},{"location":"style/#Name-formatting-1","page":"Style","title":"Name formatting","text":"","category":"section"},{"location":"style/#","page":"Style","title":"Style","text":"BibTeX-like name formatting.","category":"page"},{"location":"style/#","page":"Style","title":"Style","text":"julia> import BibTeXFormat.BST: format_name\n\njulia> name = \"Charles Louis Xavier Joseph de la Vallee Poussin\";\n\njulia> print(format_name(name, \"{vv~}{ll}{, jj}{, f.}\"))\nde~la Vallee~Poussin, C.~L. X.~J.\njulia> name = \"abc\";\n\njulia> print(format_name(name, \"{vv~}{ll}{, jj}{, f.}\"))\nabc\njulia> name = \"Jean-Pierre Hansen\";\n\njulia> print(format_name(name, \"{ff~}{vv~}{ll}{, jj}\"))\nJean-Pierre Hansen\njulia> print(format_name(name, \"{f.~}{vv~}{ll}{, jj}\"))\nJ.-P. Hansen\njulia> name = \"F. Phidias Phony-Baloney\";\n\njulia> print(format_name(name, \"{v{}}{l}\"))\nP.-B\njulia> print(format_name(name, \"{v{}}{l.}\"))\nP.-B.\njulia> print(format_name(name, \"{v{}}{l{}}\"))\nPB","category":"page"},{"location":"style/#","page":"Style","title":"Style","text":"Modules=[BibTeXFormat]\nPages = [\"style/names.jl\"]","category":"page"},{"location":"style/#","page":"Style","title":"Style","text":"Modules=[BibTeXFormat]\nPages = [\"style/names.jl\"]","category":"page"},{"location":"style/#BibTeXFormat.format","page":"Style","title":"BibTeXFormat.format","text":"function format(self::LastFirstNameStyle, person, abbr=false)\n\nFormat names similarly to {vv~}{ll}{, jj}{, f.} in BibTeX.\n\njulia> import BibTeXFormat: Person, render_as, LastFirstNameStyle, format\n\njulia> import BibTeXFormat.TemplateEngine\n\njulia> name = Person(\"Charles Louis Xavier Joseph de la Vall{\\'e}e Poussin\");\n\njulia> lastfirst = LastFirstNameStyle();\n\njulia> render_as(TemplateEngine.format(format(lastfirst,name)),\"latex\")\n\"de~la Vall{é}e~Poussin, Charles Louis Xavier~Joseph\"\n\njulia> render_as(TemplateEngine.format(format(lastfirst,name)),\"html\")\n\"de&nbsp;la Vall<span class=\"bibtex-protected\">é</span>e&nbsp;Poussin, Charles Louis Xavier&nbsp;Joseph\"\n\njulia> render_as(TemplateEngine.format(format(lastfirst,name, true)),\"latex\")\n\"de~la Vall{é}e~Poussin, C.~L. X.~J.\"\n\njulia> render_as(TemplateEngine.format(format(lastfirst,name, true)),\"html\")\n\"de&nbsp;la Vall<span class=\"bibtex-protected\">é</span>e&nbsp;Poussin, C.&nbsp;L. X.&nbsp;J.\"\n\njulia> name = Person(first=\"First\", last=\"Last\", middle=\"Middle\");\n\njulia> render_as(TemplateEngine.format(format(lastfirst,name)),\"latex\")\n\"Last, First~Middle\"\n\njulia> render_as(TemplateEngine.format(format(lastfirst,name, true)),\"latex\")\n\"Last, F.~M.\"\n\n\n\n\n\n\n","category":"function"},{"location":"style/#BibTeXFormat.format","page":"Style","title":"BibTeXFormat.format","text":"Format names similarly to {ff~}{vv~}{ll}{, jj} in BibTeX.\n\njulia> import BibTeXFormat: Person, render_as, PlainNameStyle, format\n\njulia> import BibTeXFormat.TemplateEngine\n\njulia> name = Person(\"Charles Louis Xavier Joseph de la Vall{'e}e Poussin\");\n\njulia> plain = PlainNameStyle();\n\njulia> render_as(TemplateEngine.format(format(plain, name)),\"latex\")\n\"Charles Louis Xavier~Joseph de~la Vall{é}e~Poussin\"\n\njulia> render_as(TemplatEngine.format(format(plain, name),\"html\"))\n\"Charles Louis Xavier&nbsp;Joseph de&nbsp;la Vall<span class=\"bibtex-protected\">é</span>e&nbsp;Poussin\"\n\njulia> render_as(TemplateEngine.format(format(plain,name, true)), \"latex\")\n\"C.~L. X.~J. de~la Vall{é}e~Poussin\"\n\njulia> render_as(TemplateEngine.format(format(plain, name, true)),\"html\")\n\"C.&nbsp;L. X.&nbsp;J. de&nbsp;la Vall<span class=\"bibtex-protected\">é</span>e&nbsp;Poussin\"\n\njulia> name = Person(first=\"First\", last=\"Last\", middle=\"Middle\");\n\njulia> render_as(TemplateEngine.format(format(plain, name)),\"latex\")\n\"First~Middle Last\"\n\njulia> render_as(TemplateEngine.format(format(plain,name, true)),\"latex\")\n\"F.~M. Last\"\n\njulia> render_as(TemplateEngine.format(format(plain,Person(\"de Last, Jr., First Middle\"))),\"latex\")\n\"First~Middle de~Last, Jr.\"\n\n\n\n\n\n\n","category":"function"},{"location":"style/#Labels-1","page":"Style","title":"Labels","text":"","category":"section"},{"location":"style/#","page":"Style","title":"Style","text":"Modules=[BibTeXFormat]\nPages = [\"style/labels.jl\"]","category":"page"},{"location":"style/#","page":"Style","title":"Style","text":"Modules=[BibTeXFormat]\nPages = [\"style/labels.jl\"]","category":"page"},{"location":"style/#BibTeXFormat._strip_nonalnum-Tuple{Any}","page":"Style","title":"BibTeXFormat._strip_nonalnum","text":"Strip all non-alphanumerical characters from a list of strings.\n\njulia> import BibTeXFormat: _strip_nonalnum\n\njulia> print(_strip_nonalnum([\"ÅA. B. Testing 12+}[.@~_\", \" 3%\"]))\nAABTesting123\n\n\n\n\n\n\n","category":"method"},{"location":"templateengine/#Template-Engine-1","page":"Template Engine","title":"Template Engine","text":"","category":"section"},{"location":"templateengine/#","page":"Template Engine","title":"Template Engine","text":"Pages    = [\"style/templateengine.jl\"]","category":"page"},{"location":"templateengine/#","page":"Template Engine","title":"Template Engine","text":"Modules = [BibTeXFormat.TemplateEngine]\nPages    = [\"style/templateengine.jl\"]","category":"page"},{"location":"templateengine/#BibTeXFormat.TemplateEngine.format-Tuple{BibTeXFormat.TemplateEngine.Node}","page":"Template Engine","title":"BibTeXFormat.TemplateEngine.format","text":"A convenience function to be used instead of format_data when no data is needed.\n\n\n\n\n\n","category":"method"},{"location":"templateengine/#BibTeXFormat.TemplateEngine.format_data-Tuple{BibTeXFormat.TemplateEngine.Node,Any}","page":"Template Engine","title":"BibTeXFormat.TemplateEngine.format_data","text":"Format the given data into a piece of richtext.Text\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#RichTextElements-1","page":"Rich Text Elements","title":"RichTextElements","text":"","category":"section"},{"location":"richtextelements/#","page":"Rich Text Elements","title":"Rich Text Elements","text":"DocTestSetup = quote\nimport BibTeXFormat.RichTextElements: RichText, Tag, append, render_as, add_period, capfirst,\n                    capitalize, typeinfo, create_similar, HRef,\n                    merge_similar, render_as, Protected,\n                    RichString\nend","category":"page"},{"location":"richtextelements/#Description-1","page":"Rich Text Elements","title":"Description","text":"","category":"section"},{"location":"richtextelements/#","page":"Rich Text Elements","title":"Rich Text Elements","text":"(simple but) rich text formatting tools","category":"page"},{"location":"richtextelements/#","page":"Rich Text Elements","title":"Rich Text Elements","text":"julia> import BibTeXFormat: RichText, Tag, render_as\n\njulia> import BibTeXFormat.RichTextElements: add_period, capitalize\n\njulia> t = RichText(\"this \", \"is a \", Tag(\"em\", \"very\"), RichText(\" rich\", \" text\"));\n\njulia> render_as(t,\"LaTex\")\n\"this is a \\\\emph{very} rich text\"\n\njulia> convert(String,t)\n\"this is a very rich text\"\n\njulia> t = add_period(capitalize(t));\n\njulia> render_as(t,\"latex\")\n\"This is a \\\\emph{very} rich text.\"","category":"page"},{"location":"richtextelements/#Types-1","page":"Rich Text Elements","title":"Types","text":"","category":"section"},{"location":"richtextelements/#","page":"Rich Text Elements","title":"Rich Text Elements","text":"Modules = [BibTeXFormat.RichTextElements]\nOrder   = [:type]","category":"page"},{"location":"richtextelements/#Functions-1","page":"Rich Text Elements","title":"Functions","text":"","category":"section"},{"location":"richtextelements/#","page":"Rich Text Elements","title":"Rich Text Elements","text":"Modules = [BibTeXFormat.RichTextElements]\nOrder   = [:function]","category":"page"},{"location":"richtextelements/#Reference-1","page":"Rich Text Elements","title":"Reference","text":"","category":"section"},{"location":"richtextelements/#","page":"Rich Text Elements","title":"Rich Text Elements","text":"Modules = [BibTeXFormat.RichTextElements]\nPages   = [\"richtextelements.jl\"]","category":"page"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.capitalize-Tuple{BibTeXFormat.RichTextElements.BaseText}","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.capitalize","text":"function capitalize(self::BaseText)\n\nCapitalize the first letter of the text and lowercasecase the rest.\n\njulia> import BibTeXFormat.RichTextElements: capitalize, RichText,  Tag\n\njulia> capitalize(RichText(Tag(\"em\", \"LONG CAT\")))\nRichText(Tag(\"em\", \"Long cat\"))\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.RichString","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.RichString","text":"A RichString is a wrapper for a plain Julia string.\n\njulia> import BibTeXFormat.RichTextElements: RichString, render_as\n\njulia> print(render_as(RichString(\"Crime & Punishment\"),\"text\"))\nCrime & Punishment\n\njulia> print(render_as(RichString(\"Crime & Punishment\"),\"html\"))\nCrime &amp; Punishment\n\n\n\n\n\n\n","category":"type"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.RichString-Tuple","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.RichString","text":"All arguments must be plain unicode strings. Arguments are concatenated together.\n\njulia> import BibTeXFormat.RichTextElements: RichString\n\njulia> print(convert(String,RichString(\"November\", \", \", \"December\", \".\")))\nNovember, December.\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.:+-Tuple{BibTeXFormat.RichTextElements.BaseText,Any}","page":"Rich Text Elements","title":"Base.:+","text":"function +(b::BaseText, other)\n\nConcatenate this Text with another Text or string.\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag, append, render_as\n\njulia> a = RichText(\"Longcat is \") + Tag(\"em\", \"long\")\nRichText(\"Longcat is \", Tag(\"em\", \"long\"))\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.:==-Tuple{BibTeXFormat.RichTextElements.RichString,BibTeXFormat.RichTextElements.RichString}","page":"Rich Text Elements","title":"Base.:==","text":"Compare two RichString objects.\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.Unicode.isletter-Tuple{BibTeXFormat.RichTextElements.RichString}","page":"Rich Text Elements","title":"Base.Unicode.isletter","text":"Return True if all characters in the string are alphabetic and there is at least one character, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.Unicode.isletter-Tuple{BibTeXFormat.RichTextElements.TextSymbol}","page":"Rich Text Elements","title":"Base.Unicode.isletter","text":"function isletter(self::TextSymbol)\n\nA TextSymbol is not alfanumeric. Returns false\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.Unicode.isletter-Union{Tuple{T}, Tuple{T}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.Unicode.isletter","text":"function isletter(self::T) where T<:MultiPartText\n\nReturn true if all characters in the string are alphabetic and there is at least one character, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.Unicode.lowercase-Union{Tuple{T}, Tuple{T}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.Unicode.lowercase","text":"function lowercase(self::T) where T <:MultiPartText\n\nConvert rich text to lowercasecase.\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag\n\njulia> lowercase(RichText(Tag(\"em\", \"Long cat\")))\nRichText(Tag(\"em\", \"long cat\"))\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.Unicode.uppercase-Union{Tuple{T}, Tuple{T}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.Unicode.uppercase","text":"Convert rich text to uppsercase.\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag\n\njulia> uppercase(RichText(Tag(\"em\", \"Long cat\")))\nRichText(Tag(\"em\", \"LONG CAT\"))\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.endswith-Tuple{BibTeXFormat.RichTextElements.RichString,Any}","page":"Rich Text Elements","title":"Base.endswith","text":"function endswith(self::RichString, suffix)\n\nReturn True if the string ends with the specified suffix, otherwise return False.\n\nsuffix can also be a tuple of suffixes to look for. return value.endswith(self.value text)\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.endswith-Union{Tuple{T}, Tuple{T,Any}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.endswith","text":"Return True if the text ends with the given suffix.\n\njulia> import BibTeXFormat.RichTextElements: RichText\n\njulia> endswith(RichText(\"Longcat!\"),\"cat!\")\ntrue\n\n\nSuffixes split across multiple parts are not matched:\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag\n\njulia> endswith(RichText(\"Long\", Tag(\"em\", \"cat\"), \"!\"),\"cat!\")\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.getindex-Union{Tuple{T}, Tuple{T,Integer}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.getindex","text":"Slicing and extracting characters works like with regular strings, formatting is preserved.\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag\n\njulia> RichText(\"Longcat is \", Tag(\"em\", \"looooooong!\"))[1:15]\nRichText(\"Longcat is \", Tag(\"em\", \"looo\"))\n\njulia> RichText(\"Longcat is \", Tag(\"em\", \"looooooong!\"))[end]\nRichText(Tag(\"em\", \"!\"))\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.join-Union{Tuple{T}, Tuple{T,Any}} where T<:BibTeXFormat.RichTextElements.BaseText","page":"Rich Text Elements","title":"Base.join","text":"function join(self::T, parts) where T<:BaseText\n\nJoin a list using this text (like join)\n\njulia> import BibTeXFormat.RichTextElements: RichString\n\njulia> letters = [\"a\", \"b\", \"c\"];\n\njulia> print(convert(String,join(RichString(\"-\"),letters)))\na-b-c\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.length-Union{Tuple{T}, Tuple{T}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.length","text":"lenght(text) returns the number of characters in the text, ignoring the markup:\n\njulia> import BibTeXFormat.RichTextElements: Tag, RichText, HRef\n\njulia> length(RichText(\"Long cat\"))\n8\njulia> length(RichText(Tag(\"em\", \"Long\"), \" cat\"))\n8\njulia> length(RichText(HRef(\"http://example.com/\", \"Long\"), \" cat\"))\n8\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.occursin-Union{Tuple{T}, Tuple{String,T}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.occursin","text":"value in text returns True if any part of the text occursin the substring value:\n\njulia> import BibTeXFormat.RichTextElements: RichText, occursin\n\njulia> occursin(\"Long cat\", RichText(\"Long cat!\"))\ntrue\n\nSubstrings splitted across multiple text parts are not matched:\n\njulia> import BibTeXFormat.RichTextElements: RichText, occursin, Tag\n\njulia> occursin(\"Long cat\", RichText(Tag(\"em\", \"Long\"), \"cat!\"))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.split","page":"Rich Text Elements","title":"Base.split","text":"function split(self::RichString, sep=nothing; keep_empty_parts=nothing)\n\nSplit\n\n\n\n\n\n","category":"function"},{"location":"richtextelements/#Base.split-Union{Tuple{T}, Tuple{T}, Tuple{T,Any}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.split","text":"function split(self::T, sep=nothing; keep_empty_parts=nothing) where T <:MultiPartText\n\njulia> import BibTeXFormat.RichTextElements: RichText, split\n\njulia> print(split(RichText(\"a + b\")))\nAny[RichText(\"a\"), RichText(\"+\"), RichText(\"b\")]\n\njulia> print(split(RichText(\"a, b\"), \", \"))\nAny[RichText(\"a\"), RichText(\"b\")]\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.startswith-Tuple{BibTeXFormat.RichTextElements.RichString,Any}","page":"Rich Text Elements","title":"Base.startswith","text":"function startswith(self::RichString, prefix)\n\nReturn True if string starts with the prefix, otherwise return False.\n\nprefix can also be a tuple of suffixes to look for.\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#Base.startswith-Union{Tuple{T}, Tuple{T,Any}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"Base.startswith","text":"function startswith(self::T, prefix) where T<:MultiPartText\n\nReturn True if the text starts with the given prefix.\n\njulia> import BibTeXFormat.RichTextElements: RichText\n\njulia> startswith(RichText(\"Longcat!\"),\"Longcat\")\ntrue\n\nPrefixes split across multiple parts are not matched:\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag\n\njulia> startswith(RichText(Tag(\"em\", \"Long\"), \"cat!\"),\"Longcat\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.add_period","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.add_period","text":"function add_period(self::BaseText, period=\".\")\n\nAdd a period to the end of text, if the last character is not \".\", \"!\" or \"?\".\n\njulia> import BibTeXFormat.RichTextElements: RichText, add_period\n\njulia> text = RichText(\"That's all, folks\");\n\njulia> print(convert(String,add_period(text)))\nThat's all, folks.\n\njulia> text = RichText(\"That's all, folks!\");\n\njulia> print(convert(String,add_period(text)))\nThat's all, folks!\n\n\n\n\n\n","category":"function"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.append-Tuple{BibTeXFormat.RichTextElements.BaseText,Any}","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.append","text":"function append(self::BaseText, text)\n\nAppend text to the end of this text.\n\nNormally, this is the same as concatenating texts with +, but for tags and similar objects the appended text is placed inside the tag.\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag, append, render_as\n\njulia> text = Tag(\"em\", \"Look here\");\n\njulia> print(render_as(text + \"!\",\"html\"))\n<em>Look here</em>!\n\njulia> print(render_as(append(text,\"!\"),\"html\"))\n<em>Look here!</em>\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.append-Union{Tuple{T}, Tuple{T,Any}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.append","text":"function  append(self::T, text) where T<:MultiPartText\n\nAppend text to the end of this text.\n\nFor Tags, HRefs, etc. the appended text is placed inside the tag.\n\njulia> import BibTeXFormat.RichTextElements: Tag, render_as, HRef, append\n\njulia> text = Tag(\"strong\", \"Chuck Norris\");\n\njulia> print(render_as(text +  \" wins!\",\"html\"))\n<strong>Chuck Norris</strong> wins!\n\njulia> print(render_as(append(text,\" wins!\"),\"html\"))\n<strong>Chuck Norris wins!</strong>\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.capfirst-Tuple{BibTeXFormat.RichTextElements.BaseText}","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.capfirst","text":"function capfirst(self::BaseText)\n\nCapitalize the first letter of the text.\n\njulia> import BibTeXFormat.RichTextElements: capfirst, RichText,  Tag\n\njulia> capfirst(RichText(Tag(\"em\", \"long Cat\")))\nRichText(Tag(\"em\", \"Long Cat\"))\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.create_similar-Union{Tuple{T}, Tuple{T,Any}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.create_similar","text":"function create_similar(self::T, parts) where T<:MultiPartText\n\nCreate a new text object of the same type with the same parameters, with different text content.\n\njulia> import BibTeXFormat.RichTextElements: Tag, create_similar\n\njulia> text = Tag(\"strong\", \"Bananas!\");\n\njulia> create_similar(text,[\"Apples!\"])\nTag(\"strong\", \"Apples!\")\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.initialize_parts-Tuple","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.initialize_parts","text":"Initialize the parts. A MutliPartText elements must have the following members\n\ntype atype <: MultiPartText\n\tparts\n\tlength\n\tinfo\nend\n\nEmpty parts are ignored:\n\njulia> import BibTeXFormat.RichTextElements: Tag, RichText, HRef\n\njulia> RichText() == RichText(\"\") == RichText(\"\", \"\", \"\")\ntrue\njulia> RichText(\"Word\", \"\") == RichText(\"Word\")\ntrue\n\nText() objects are unpacked and their children are included directly:\n\njulia> import BibTeXFormat.RichTextElements: Tag, RichText, HRef\n\njulia> RichText(RichText(\"Multi\", \" \"), Tag(\"em\", \"part\"), RichText(\" \", RichText(\"text!\")))\nRichText(\"Multi \", Tag(\"em\", \"part\"), \" text!\")\n\njulia> Tag(\"strong\", RichText(\"Multi\", \" \"), Tag(\"em\", \"part\"), RichText(\" \", \"text!\"))\nTag(\"strong\", \"Multi \", Tag(\"em\", \"part\"), \" text!\")\n\n\nSimilar objects are merged together:\n\njulia> import BibTeXFormat.RichTextElements: Tag, RichText, HRef\n\njulia> RichText(\"Multi\", Tag(\"em\", \"part\"), RichText(Tag(\"em\", \" \", \"text!\")))\nRichText(\"Multi\", Tag(\"em\", \"part text!\"))\n\njulia> RichText(\"Please \", HRef(\"/\", \"click\"), HRef(\"/\", \" here\"), \".\")\nRichText(\"Please \", HRef(\"/\", \"click here\"), \".\")\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.merge_similar-Tuple{Array}","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.merge_similar","text":"function merge_similar(param_parts)\n\nMerge adjacent text objects with the same type and parameters together.\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag, merge_similar\n\njulia> parts = [Tag(\"em\", \"Breaking\"), Tag(\"em\", \" \"), Tag(\"em\", \"news!\")];\n\njulia> print(merge_similar(parts))\nAny[Tag(\"em\", \"Breaking news!\")]\n\njulia> parts = [Tag(\"em\", \"Breaking\"), Tag(\"em\", \" \"), Tag(\"ol\", \"news!\")];\n\njulia> print(merge_similar(parts))\nAny[Tag(\"em\", \"Breaking \"), Tag(\"ol\", \"news!\")]\n\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.slice_beginning-Union{Tuple{T}, Tuple{T,Integer}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.slice_beginning","text":"Return a text consistng of the first slice_length characters of this text (with formatting preserved).\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.slice_end-Union{Tuple{T}, Tuple{T,Integer}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.slice_end","text":"function slice_end(self::T, slice_length::Integer) where T<:MultiPartText\n\nReturn a text consistng of the last slice_length characters of this text (with formatting preserved).\n\n\n\n\n\n","category":"method"},{"location":"richtextelements/#BibTeXFormat.RichTextElements.typeinfo-Union{Tuple{T}, Tuple{T}} where T<:BibTeXFormat.RichTextElements.MultiPartText","page":"Rich Text Elements","title":"BibTeXFormat.RichTextElements.typeinfo","text":"function  typeinfo(self::T) where T<:MultiPartText\n\nReturn the type and the parameters used to create this text object.\n\njulia> using BibTeXFormat\n\njulia> import BibTeXFormat.RichTextElements: Tag, typeinfo\n\njulia> text = Tag(\"strong\", \"Heavy rain!\");\n\njulia> typeinfo(text) == (\"Tag\", Tag, \"strong\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"person/#Person-1","page":"Person","title":"Person","text":"","category":"section"},{"location":"person/#","page":"Person","title":"Person","text":"Pages    = [\"person.jl\"]","category":"page"},{"location":"person/#","page":"Person","title":"Person","text":"Modules = [BibTeXFormat]\nPages    = [\"person.jl\"]","category":"page"},{"location":"person/#BibTeXFormat.Person","page":"Person","title":"BibTeXFormat.Person","text":"A person or some other person-like entity.\n\njulia> import BibTeXFormat.Person;\n\njulia> knuth = Person(\"Donald E. Knuth\");\n\njulia> knuth.first_names\n1-element Array{String,1}:\n \"Donald\"\n\njulia> knuth.middle_names\n1-element Array{String,1}:\n \"E.\"\n\njulia> knuth.last_names\n1-element Array{String,1}:\n \"Knuth\"\n\n\n\n\n\n","category":"type"},{"location":"person/#BibTeXFormat.Person","page":"Person","title":"BibTeXFormat.Person","text":"Construct a Person from a full name string . It will be parsed and split into separate first, last, middle, pre-last and lineage name parst.\n\nSupported name formats are:\n\nvon Last, First\nvon Last, Jr, First\nFirst von Last\n\n(see BibTeX manual for explanation)\n\n\n\n\n\n","category":"type"},{"location":"person/#Base.convert-Tuple{Type{String},BibTeXFormat.Person}","page":"Person","title":"Base.convert","text":"von Last, Jr, First\n\n\n\n\n\n","category":"method"},{"location":"person/#BibTeXFormat._parse_string-Tuple{BibTeXFormat.Person,String}","page":"Person","title":"BibTeXFormat._parse_string","text":"Extract various parts of the name from a string.\n\njulia> import BibTeXFormat: Person\n\njulia> p = Person(\"Avinash K. Dixit\");\n\njulia> p.first_names\n1-element Array{String,1}:\n \"Avinash\"\n\njulia> p.middle_names\n1-element Array{String,1}:\n \"K.\"\n\njulia> p.prelast_names\n0-element Array{String,1}\n\njulia> p.last_names\n1-element Array{String,1}:\n \"Dixit\"\n\njulia> p.lineage_names\n0-element Array{String,1}\n\njulia> convert(String,p)\n\"Dixit, Avinash K.\"\n\njulia> p == Person(convert(String,p))\ntrue\n\njulia> p = Person(\"Dixit, Jr, Avinash K. \");\n\njulia> p.first_names\n1-element Array{String,1}:\n \"Avinash\"\n\njulia> p.middle_names\n1-element Array{String,1}:\n \"K.\"\n\njulia> print(p.prelast_names)\nString[]\njulia> print(p.last_names)\n[\"Dixit\"]\njulia> print(p.lineage_names)\n[\"Jr\"]\njulia> print(convert(String,p))\nDixit, Jr, Avinash K.\njulia> p == Person(convert(String,p))\ntrue\n\njulia> p = Person(\"abc\");\n\njulia> print(p.first_names, p.middle_names, p.prelast_names, p.last_names, p.lineage_names)\nString[]String[]String[][\"abc\"]String[]\njulia> p = Person(\"Viktorov, Michail~Markovitch\");\n\njulia> print(p.first_names, p.middle_names, p.prelast_names, p.last_names, p.lineage_names)\n[\"Michail\"][\"Markovitch\"]String[][\"Viktorov\"]String[]\n\n\n\n\n\n","category":"method"},{"location":"person/#BibTeXFormat.bibtex_first_names-Tuple{BibTeXFormat.Person}","page":"Person","title":"BibTeXFormat.bibtex_first_names","text":"A list of first and middle names together. (BibTeX treats all middle names as first.)\n\njulia> import BibTeXFormat: Person, bibtex_first_names\n\njulia> knuth = Person(\"Donald E. Knuth\");\n\njulia> bibtex_first_names(knuth)\n2-element Array{String,1}:\n \"Donald\"\n \"E.\"\n\n\n\n\n\n\n","category":"method"},{"location":"person/#BibTeXFormat.get_part","page":"Person","title":"BibTeXFormat.get_part","text":"Get a list of name parts by type.\n\njulia> import BibTeXFormat: Person, get_part;\n\njulia> knuth = Person(\"Donald E. Knuth\");\n\njulia> get_part(knuth,\"first\")\n1-element Array{String,1}:\n \"Donald\"\n\njulia> get_part(knuth,\"last\")\n1-element Array{String,1}:\n \"Knuth\"\n\n\n\n\n\n\n","category":"function"},{"location":"person/#BibTeXFormat.rich_first_names-Tuple{BibTeXFormat.Person}","page":"Person","title":"BibTeXFormat.rich_first_names","text":"A list of first names converted to :ref:rich text <rich-text>.\n\n\n\n\n\n","category":"method"},{"location":"person/#BibTeXFormat.rich_last_names-Tuple{BibTeXFormat.Person}","page":"Person","title":"BibTeXFormat.rich_last_names","text":"A list of last names converted to :ref:rich text <rich-text>.\n\n\n\n\n\n","category":"method"},{"location":"person/#BibTeXFormat.rich_lineage_names-Tuple{BibTeXFormat.Person}","page":"Person","title":"BibTeXFormat.rich_lineage_names","text":"A list of lineage (aka Jr) name parts converted to :ref:rich text <rich-text>.\n\n\n\n\n\n","category":"method"},{"location":"person/#BibTeXFormat.rich_middle_names-Tuple{BibTeXFormat.Person}","page":"Person","title":"BibTeXFormat.rich_middle_names","text":"A list of middle names converted to :ref:rich text <rich-text>.\n\n\n\n\n\n","category":"method"},{"location":"person/#BibTeXFormat.rich_prelast_names-Tuple{BibTeXFormat.Person}","page":"Person","title":"BibTeXFormat.rich_prelast_names","text":"A list of pre-last (aka von) name parts converted to :ref:rich text <rich-text>.\n\n\n\n\n\n","category":"method"},{"location":"backends/markdown/#Markdown-backend-1","page":"Markdown backend","title":"Markdown backend","text":"","category":"section"},{"location":"backends/markdown/#","page":"Markdown backend","title":"Markdown backend","text":"Markdown output backend.","category":"page"},{"location":"backends/markdown/#","page":"Markdown backend","title":"Markdown backend","text":"julia> import BibTeXFormat.RichTextElements: Tag, HRef\n\njulia> import BibTeXFormat: MarkdownBackend, render\n\njulia> markdown = MarkdownBackend();\n\njulia> print(render(Tag(\"em\", \"\"),markdown))\n\njulia> print(render(Tag(\"em\", \"Non-\", \"empty\"),markdown))\n*Non\\-empty*\n\njulia> print(render(HRef(\"/\", \"\"),markdown))\n\njulia> print(render(HRef(\"/\", \"Non-\", \"empty\"),markdown))\n[Non\\-empty](/)\n","category":"page"},{"location":"backends/#Backends-1","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Pages    = [\"backends/backends.jl\"]","category":"page"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Modules = [BibTeXFormat]\nPages    = [\"backends/backends.jl\"]","category":"page"},{"location":"backends/#BibTeXFormat.write_to_file-Tuple{Any,Any,Any}","page":"Backends","title":"BibTeXFormat.write_to_file","text":"function  write_to_file(self, formatted_entries, filename)\n\n\n\n\n\n","category":"method"},{"location":"backends/#BibTeXFormat.write_to_stream","page":"Backends","title":"BibTeXFormat.write_to_stream","text":"function write_to_stream(self::BaseBackend, formatted_bibliography::Array, stream=IOBuffer(), citations::Vector{String})\n\nGiven a list of formatted bibliography, formatted_bibliography, the function generates the output according to self::BaseBackend specificed. The output includes the prologue and the epilogue.\n\n\n\n\n\n","category":"function"},{"location":"backends/#BibTeXFormat.write_to_stream","page":"Backends","title":"BibTeXFormat.write_to_stream","text":"function write_to_stream(self::BaseBackend, formatted_bibliography::Array, stream=IOBuffer())\n\nGiven a list of formatted bibliography, formatted_bibliography, the function generates the output according to self::BaseBackend specificed. The output includes the prologue and the epilogue.\n\n\n\n\n\n","category":"function"},{"location":"backends/#BibTeXFormat.write_to_stream","page":"Backends","title":"BibTeXFormat.write_to_stream","text":"function write_to_stream(self::BaseBackend, formatted_bibliography_item:Tuple, stream=IOBuffer())\n\nGiven a formatted_bibliography_item, the function generates the output according to self::BaseBackend specificed.\n\n\n\n\n\n","category":"function"},{"location":"backends/#BibTeXFormat.write_to_string-Tuple{Any,Any,Array{String,1}}","page":"Backends","title":"BibTeXFormat.write_to_string","text":"function write_to_string(self, formatted_entries, citations::Vector{String})\n\n\n\n\n\n","category":"method"},{"location":"backends/#BibTeXFormat.write_to_string-Tuple{Any,Any}","page":"Backends","title":"BibTeXFormat.write_to_string","text":"function write_to_string(self, formatted_entries)\n\n\n\n\n\n","category":"method"},{"location":"backends/#BibTeXFormat.BaseBackend","page":"Backends","title":"BibTeXFormat.BaseBackend","text":"This is the base type for the backends. We encourage you to implement as many of the symbols and tags as possible when you create a new plugin.\n\nsymbols[\"ndash\"]    : Used to separate pages\nsymbols[\"newblock\"] : Used to separate entries in the bibliography\nsymbols[\"bst_script\"]      : A non-breakable space\ntags[\"\"em']   : emphasize text\ntags[\"strong\"]: emphasize text even more\ntags[\"i\"]     : italicize text, not semantic\ntags[\"b\"]     : embolden text, not semantic\ntags[\"tt\"]    : typewrite text, not semantic\n\n\n\n\n\n","category":"type"},{"location":"backends/#BibTeXFormat.format-Union{Tuple{T}, Tuple{T,BibTeXFormat.RichTextElements.Protected,Any}} where T<:BibTeXFormat.BaseBackend","page":"Backends","title":"BibTeXFormat.format","text":"function format(self::T, t::Protected, text) where T<:BaseBackend\n\nFormat a \"protected\" piece of text.\n\nIn LaTeX backend, it is formatted as a {braced group}. Most other backends would just output the text as-is.\n\n\n\n\n\n","category":"method"},{"location":"backends/#BibTeXFormat.format-Union{Tuple{T}, Tuple{T,String}} where T<:BibTeXFormat.BaseBackend","page":"Backends","title":"BibTeXFormat.format","text":"function format(self::T, str::String) where T<:BaseBackend\n\nFormat the given string str_. The default implementation simply returns the string ad verbatim. Override this method for non-string backends.\n\n\n\n\n\n","category":"method"},{"location":"backends/#BibTeXFormat.render_sequence-Union{Tuple{T}, Tuple{T,Any}} where T<:BibTeXFormat.BaseBackend","page":"Backends","title":"BibTeXFormat.render_sequence","text":"function render_sequence(self::T, rendered_list) where T <:BaseBackend\n\nRender a sequence of rendered Text objects. The default implementation simply concatenates the strings in rendered_list. Override this method for non-string backends.\n\n\n\n\n\n","category":"method"},{"location":"backends/#HTML-1","page":"Backends","title":"HTML","text":"","category":"section"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Pages    = [\"backends/html.jl\"]","category":"page"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Modules = [BibTeXFormat]\nPages    = [\"backends/html.jl\"]","category":"page"},{"location":"backends/#BibTeXFormat.HTMLBackend","page":"Backends","title":"BibTeXFormat.HTMLBackend","text":"struct HTMLBackend <: BaseBackend\n\njulia> import BibTeXFormat.RichTextElements: RichText, Tag, TextSymbol\n\njulia> import BibTeXFormat: render, HTMLBackend\n\njulia> print(render(Tag(\"em\", RichText(\"Ð›.:\", TextSymbol(\"nbsp\"), \"<<Ð¥Ð¸Ð¼Ð¸Ñ>>\")),HTMLBackend()))\n<em>Ð›.:&nbsp;&lt;&lt;Ð¥Ð¸Ð¼Ð¸Ñ&gt;&gt;</em>\n\n\n\n\n\n","category":"type"},{"location":"backends/#LaTeX-1","page":"Backends","title":"LaTeX","text":"","category":"section"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Pages    = [\"backends/latex.jl\"]","category":"page"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Modules = [BibTeXFormat]\nPages    = [\"backends/latex.jl\"]","category":"page"},{"location":"backends/#BibTeXFormat.LaTeXBackend","page":"Backends","title":"BibTeXFormat.LaTeXBackend","text":"LaTeX output backend.\n\njulia> import BibTeXFormat: LaTeXBackend, render\n\njulia> import BibTeXFormat.RichTextElements: Tag, HRef\n\njulia> latex = LaTeXBackend();\n\njulia> print(render(Tag(\"em\", \"\"),latex))\n\njulia> print(render(Tag(\"em\", \"Non-\", \"empty\"),latex))\n\\emph{Non-empty}\njulia> print(render(HRef(\"/\", \"\"),latex))\n\njulia> print(render(HRef(\"/\", \"Non-\", \"empty\"),latex))\n\\href{/}{Non-empty}\njulia> print(render(HRef(\"http://example.org/\", \"http://example.org/\"),latex))\n\\url{http://example.org/}\n\n\n\n\n\n","category":"type"},{"location":"backends/#BibTeXFormat.format-Tuple{LaTeXBackend,BibTeXFormat.RichTextElements.Protected,Any}","page":"Backends","title":"BibTeXFormat.format","text":"function format(self::LaTeXBackend, p::Protected, text)\n\njulia> import BibTeXFormat.RichTextElements: Protected\n\njulia> import BibTeXFormat: render_as\n\njulia> print(render_as(Protected(\"CTAN\"), \"latex\"))\n{CTAN}\n\n\n\n\n\n","category":"method"},{"location":"backends/#Markdown-1","page":"Backends","title":"Markdown","text":"","category":"section"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Pages    = [\"backends/markdown.jl\"]","category":"page"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Modules = [BibTeXFormat]\nPages    = [\"backends/markdown.jl\"]","category":"page"},{"location":"backends/#BibTeXFormat.MarkdownBackend","page":"Backends","title":"BibTeXFormat.MarkdownBackend","text":"A backend to support markdown output. It implements the same features as the HTML backend.\n\nIn addition to that, you can use the keyword php_extra=True to enable the definition list extension of php-markdown. The default is not to use it, since we cannot be sure that this feature is implemented on all systems.\n\nMore information: http://www.michelf.com/projects/php-markdown/extra/#def-list\n\n\n\n\n\n","category":"type"},{"location":"backends/#BibTeXFormat.format-Tuple{MarkdownBackend,String}","page":"Backends","title":"BibTeXFormat.format","text":"Format the given string str_. Escapes special markdown control characters.\n\n\n\n\n\n","category":"method"},{"location":"backends/#Text-1","page":"Backends","title":"Text","text":"","category":"section"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Pages    = [\"backends/plaintext.jl\"]","category":"page"},{"location":"backends/#","page":"Backends","title":"Backends","text":"Modules = [BibTeXFormat]\nPages    = [\"backends/plaintext.jl\"]","category":"page"},{"location":"#BibTeXFormat-1","page":"Home","title":"BibTeXFormat","text":"","category":"section"},{"location":"#Markdown-example-1","page":"Home","title":"Markdown example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using BibTeX\nusing BibTeXFormat\nusing Markdown\n\nopen_file(x) = open(joinpath(dirname(pathof(BibTeXFormat)), \"../\", x ))\nbibliography = Bibliography(read(open_file(\"test/Clustering.bib\"), String))\nformatted_entries = format_entries(AlphaStyle,bibliography)\nmdoutput = write_to_string( MarkdownBackend(),formatted_entries)\nmdoutput_parsed = Markdown.parse(mdoutput)","category":"page"},{"location":"#output-1","page":"Home","title":"output","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using BibTeX\nusing BibTeXFormat\nusing Markdown\n\nopen_file(x) = open(joinpath(dirname(pathof(BibTeXFormat)), \"../\", x ))\nbibliography = Bibliography(read(open_file(\"test/Clustering.bib\"), String))\nformatted_entries = format_entries(AlphaStyle,bibliography)\nmdoutput = write_to_string( MarkdownBackend(),formatted_entries)\nmdoutput_parsed = Markdown.parse(mdoutput)","category":"page"},{"location":"#HTML-example-1","page":"Home","title":"HTML example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using BibTeX\nusing BibTeXFormat\nusing Markdown\n\nopen_file(x) = open(joinpath(dirname(pathof(BibTeXFormat)), \"../\", x))\nbibliography = Bibliography(read(open_file(\"test/Clustering.bib\"), String))\nformatted_entries = format_entries(AlphaStyle,bibliography)\nhtmlbackend   = HTMLBackend(\"uft-8\") # No prolog and epilog\nwrite_to_file( htmlbackend ,formatted_entries, \"html_test.html\")\nnothing # hide","category":"page"},{"location":"#output-2","page":"Home","title":"output","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Result","category":"page"},{"location":"#LaTeX-example-1","page":"Home","title":"LaTeX example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using BibTeX\nusing BibTeXFormat\nusing Markdown\n\nopen_file(x) = open(joinpath(dirname(pathof(BibTeXFormat)), \"../\", x))\nbibliography = Bibliography(read(open_file(\"test/Clustering.bib\"), String))\nformatted_entries = format_entries(AlphaStyle,bibliography)\nlatexbackend = LaTeXBackend() # No prolog and epilog\nwrite_to_file( latexbackend ,formatted_entries, \"latex_test.aux\")\nnothing # hide","category":"page"},{"location":"#output-3","page":"Home","title":"output","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Result","category":"page"},{"location":"#Plain-text-example-1","page":"Home","title":"Plain text example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using BibTeX\nusing BibTeXFormat\nusing Markdown\n\nopen_file(x) = open(joinpath(dirname(pathof(BibTeXFormat)), \"../\", x))\nbibliography = Bibliography(read(open_file(\"test/Clustering.bib\"), String))\nformatted_entries = format_entries(AlphaStyle,bibliography)\nwrite_to_file( TextBackend(),formatted_entries, \"text_test.txt\")","category":"page"},{"location":"#output-4","page":"Home","title":"output","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Result","category":"page"},{"location":"utils/#Utilities-1","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#Types-1","page":"Utilities","title":"Types","text":"","category":"section"},{"location":"utils/#","page":"Utilities","title":"Utilities","text":"Pages   = [\"utils.md\"]","category":"page"},{"location":"utils/#Reference-1","page":"Utilities","title":"Reference","text":"","category":"section"},{"location":"utils/#","page":"Utilities","title":"Utilities","text":"Modules = [BibTeXFormat]\nPages   = [\"utils.jl\", \"latexparser.jl\"]","category":"page"},{"location":"utils/#BibTeXFormat.BibTeXString","page":"Utilities","title":"BibTeXFormat.BibTeXString","text":"julia> import BibTeXFormat: BibTeXString\n\njulia> a = BibTeXString(\"{aaaa{bbbb{cccc{dddd}}}ffff}\");\n\njulia> convert(String,a ) == \"{aaaa{bbbb{cccc{dddd}}}ffff}\"\ntrue\n\n\n\n\n\n","category":"type"},{"location":"utils/#BibTeXFormat.abbreviate","page":"Utilities","title":"BibTeXFormat.abbreviate","text":"Abbreviate the given text.\n\njulia> import BibTeXFormat.abbreviate\n\njulia> abbreviate(\"Name\")\n\"N.\"\n\njulia> abbreviate(\"Some words\")\n\"S. w.\"\n\njulia> abbreviate(\"First-Second\")\n\"F.-S.\"\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#BibTeXFormat.bibtex_abbreviate","page":"Utilities","title":"BibTeXFormat.bibtex_abbreviate","text":"function bibtex_abbreviate(string, delimiter=None, separator='-')\n\nAbbreviate string.\n\njulia> import BibTeXFormat: bibtex_abbreviate\n\njulia> print(bibtex_abbreviate(\"Andrew Blake\"))\nA\njulia> print(bibtex_abbreviate(\"Jean-Pierre\"))\nJ.-P\njulia> print(bibtex_abbreviate(\"Jean--Pierre\"))\nJ.-P\n\n\n\n\n\n","category":"function"},{"location":"utils/#BibTeXFormat.bibtex_substring-Tuple{Any,Any,Any}","page":"Utilities","title":"BibTeXFormat.bibtex_substring","text":"function bibtex_substring(string, start, length)\n\nReturn a substring of the given length, starting from the given position.\n\nstart and length are 1-based. If start is < 0, it is counted from the end of the string. If start is 0, an empty string is returned.\n\njulia> import BibTeXFormat: bibtex_substring\n\njulia> print(bibtex_substring(\"abcdef\", 1, 3))\nabc\njulia> print(bibtex_substring(\"abcdef\", 2, 3))\nbcd\njulia> print(bibtex_substring(\"abcdef\", 2, 1000))\nbcdef\njulia> print(bibtex_substring(\"abcdef\", 0, 1000))\n\njulia> print(bibtex_substring(\"abcdef\", -1, 1))\nf\njulia> print(bibtex_substring(\"abcdef\", -1, 2))\nef\njulia> print(bibtex_substring(\"abcdef\", -2, 3))\ncde\njulia> print(bibtex_substring(\"abcdef\", -2, 1000))\nabcde\n\n\n\n\n\n","category":"method"},{"location":"utils/#BibTeXFormat.change_case-Tuple{String,Char}","page":"Utilities","title":"BibTeXFormat.change_case","text":"function change_case(string, mode)\n\njulia> import BibTeXFormat: change_case\n\njulia> print(change_case(\"aBcD\", 'l'))\nabcd\njulia> print(change_case(\"aBcD\", 'u'))\nABCD\njulia> print(change_case(\"ABcD\", 't'))\nAbcd\njulia> change_case(\"The {\\TeX book \\noop}\", 'u')\n\"THE {\\TeX BOOK \\noop}\"\n\njulia> change_case(\"And Now: BOOO!!!\", 't')\n\"And now: Booo!!!\"\n\njulia> change_case(\"And {Now: BOOO!!!}\", 't')\n\"And {Now: BOOO!!!}\"\n\njulia> change_case(\"And {Now: {BOOO}!!!}\", 'l')\n\"and {Now: {BOOO}!!!}\"\n\njulia> change_case(\"And {\\Now: BOOO!!!}\", 't')\n\"And {\\Now: booo!!!}\"\n\njulia> change_case(\"And {\\Now: {BOOO}!!!}\", 'l')\n\"and {\\Now: {booo}!!!}\"\n\njulia> change_case(\"{\\TeX\\ and databases\\Dash\\TeX DBI}\", 't')\n\"{\\TeX\\ and databases\\Dash\\TeX DBI}\"\n\n\n\n\n\n\n","category":"method"},{"location":"utils/#BibTeXFormat.scan_bibtex_string-Tuple{Any}","page":"Utilities","title":"BibTeXFormat.scan_bibtex_string","text":"Yield (char, brace_level) tuples.\n\n\"Special characters\", as in bibtex_len, are treated as a single character\n\n\n\n\n\n","category":"method"},{"location":"utils/#BibTeXFormat.split_keep_separator","page":"Utilities","title":"BibTeXFormat.split_keep_separator","text":"Split a text keep the separators\n\njulia> import BibTeXFormat.split_keep_separator\n\njulia> split_keep_separator(\"Some words-words\")\n5-element Array{Any,1}:\n \"Some\"\n ' '\n \"words\"\n '-'\n \"words\"\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#BibTeXFormat.split_name_list-Tuple{Any}","page":"Utilities","title":"BibTeXFormat.split_name_list","text":"Split a list of names, separated by ' and '.\n\njulia> import BibTeXFormat.split_name_list\n\njulia> split_name_list(\"Johnson and Peterson\")\n2-element Array{SubString{String},1}:\n \"Johnson\"\n \"Peterson\"\n\njulia> split_name_list(\"Johnson AND Peterson\")\n2-element Array{SubString{String},1}:\n \"Johnson\"\n \"Peterson\"\n\njulia> split_name_list(\"Johnson AnD Peterson\")\n2-element Array{SubString{String},1}:\n \"Johnson\"\n \"Peterson\"\n\njulia> split_name_list(\"Armand and Peterson\")\n2-element Array{SubString{String},1}:\n \"Armand\"\n \"Peterson\"\n\njulia> split_name_list(\"Armand and anderssen\")\n2-element Array{SubString{String},1}:\n \"Armand\"\n \"anderssen\"\n\njulia> split_name_list(\"{Armand and Anderssen}\")\n1-element Array{SubString{String},1}:\n \"{Armand and Anderssen}\"\n\njulia> split_name_list(\"What a Strange{ }and Bizzare Name! and Peterson\")\n2-element Array{SubString{String},1}:\n \"What a Strange{ }and Bizzare Name!\"\n \"Peterson\"\n\njulia> split_name_list(\"What a Strange and{ }Bizzare Name! and Peterson\")\n2-element Array{SubString{String},1}:\n \"What a Strange and{ }Bizzare Name!\"\n \"Peterson\"\n\n\n\n\n\n","category":"method"}]
}
